package org.idc.xml.renderers;//Java Importsimport org.shakra.common.config.Configimport org.shakra.common.file.FileSystemimport java.sql.ResultSetMetaData
// Groovy Importsimport groovy.xml.MarkupBuilder
import org.idc.common.sql.DatabaseConnector
import org.idc.common.exceptions.CTBTOException




public class RawDBRenderer extends DBRenderer
{
	private _staticTablesList	private _dynamicTablesList	private _limits = [:]
	private _extractionDir	private _dbConn
	
	public def RawDBRenderer()
	{			_init()
	}	
		/**	 * Create a database dump from the static and dynamic tables in the configuration file	 * All the content is extracted from the static tables and only the content of the sampleIDs passed	 * by the user are extracted from the dynamic tables	 * @param sampleIDs sampleIDs	 */	public def render(sampleIDs = [])	{		def tempo = ""		def limit					// get data of the static tables		for (table in _staticTablesList)		{					// remove spaces from tablename			table = table.trim()							tempo = _generateTableFilename(table)							// if there is limit update limit			if (this._limits.containsKey(table))			{			   limit = this._limits[table]			}			else			{			   limit = 0			}							// hoover in data			this._saveTableContentIn(table,"${_extractionDir}/${tempo}.xml",limit)		}	        	    // preparation for get the data from the dynamic tables	    // create a string of sampleIds		def strSampleIDs = sampleIDs.join(", ")		def sqlWhere = ""				if ( strSampleIDs.size() > 0)		{				sqlWhere = " where SAMPLE_ID in ( $strSampleIDs )"		}	        	    // for the moment always add metadata	    def addMetadata = true	        	    def sqlRequest = "" 	    	    println " Filter the following table retrievals with $strSampleIDs"					// get dynamic data		for (table in _dynamicTablesList)		{	       //remove spaces from tablename		   table = table.trim()			   		   sqlRequest = "select * from " + table + sqlWhere			   		   tempo = _generateTableFilename(table)					   this._storeRequestResultInXml(table,"${_extractionDir}/${tempo}.xml",sqlRequest,addMetadata)		}  	}		/** 	 * Generate a file name for the table	 */	private def _generateTableFilename(tablename)	{		// replace all . with _		def result = (tablename =~ /\./).replaceAll("_")				return result	}		public def _init()	{		// get DB Connection		this._dbConn = new DatabaseConnector()				// read configuration for the Raw Render		_readConfig()                // create directories if necessary         FileSystem.createDirs(this._extractionDir)                // connect to the DB        this._dbConn.connect();        	}	
	/**_init()	 * get the necessary parameters from the configuration file	 */
	private def _readConfig() throws CTBTOException
	{		println "get table list"		
		// get the list of tables to dump
		if ( (_staticTablesList =  Config.stringsAt("RawDBRenderer","static_tables")) == null)
			throw new CTBTOException("Error: needs a list of static tables to extract")				if ( (_dynamicTablesList =  Config.stringsAt("RawDBRenderer","dynamic_tables")) == null)		{			//throw new CTBTOException("Error: needs a list of tables to extract")			_dynamicTablesList = []		}				// get limit values for each table		def dummyList = Config.stringsAt("RawDBRenderer","limits")				if ( dummyList != null)		{			def tableInfo = null;			def items     = null;						dummyList.each {				tableInfo = it				items = tableInfo.split(':')								// syntax error if there are more or less than 2 elements				if (items.size() != 2)					throw new CTBTOException("Parse Error. the limit ${tableInfo} should be formatted following tablename:limit. For Example limits=GARDS_STATION:10,GARDS_DATA:1000")							_limits[items[0]] = items[1]			}		}					println "Got the limits"
		
		_extractionDir = Config.at("RawDBRenderer","extractionDir","/tmp")
			
	}		private def _getMetadataDefinition(resultSet)	{	    def inMap = null	    def list = []		ResultSetMetaData metaData = resultSet.getMetaData();					int count = metaData.getColumnCount();					for (int i = 1; i <= count; i++) 		{			inMap = [:]							inMap["name"]         = metaData.getColumnName(i)			inMap["id"]           = i			inMap["type"]         = metaData.getColumnType(i)			inMap["length"]       = metaData.getPrecision(i)			inMap["isNullable"]   = metaData.isNullable(i)							if (inMap.size() > 0) list[i-1] = inMap		}					return list	 }		/**	 * Add DB Metadata	 * @param tablename name of the table to dump	 * @param filename filename where to write the xmlized DB dump	 * @param sampleIDs list of sampleIDs 	 * 	*/    private def _storeMetadata(xml,row)    {    	def l = this._getMetadataDefinition(row)    	    	xml.metadata    	{    	     	   l.each() {    		   info ->    		   xml.column    		   {    			   xml.col_id(info["id"])    			   xml.name(info["name"])    			   xml.type(info["type"])    			       			   if (info["length"] > 0) xml.data_lengh(info["length"])    			       			   (info["isNullable"]) ? xml.nullable("TRUE") : xml.nullable("FALSE")    			       		   }    	   }    	}    	    	// no pbs return true    	return true    }	    /**     * Dump the content of specified table in an XML file following the specified xml dialect     * @param tablename name of the table to dump     * @param filename filename where to write the xmlized DB dump     *      */ 	public def _saveTableContentIn(tablename, filename,limit = 0) 	{ 		def strLimit = "all" 		def sqlLimit = "" 		 		if ( limit != 0) 		{ 			strLimit = limit 			sqlLimit = " where rownum <= ${limit}" 		} 		 		println "Dump table ${tablename} in ${filename}" 		 		def out    = new File(filename) 		def writer = new FileWriter( out ) 		def xml    = new MarkupBuilder( writer ) 		 		def cpt         = 1 		def key         = null 		def map         = null 		def val         = null 		def hasMetadata = false 		 		def dataSql     = "SELECT * FROM " + tablename + sqlLimit 		 		 xml.table(name:"${tablename}") 		 { 			try 			{ 		      _dbConn.eachRow(dataSql)  		      { 			      row ->  			       			      if (! hasMetadata)  			      { 			    	  hasMetadata = this._storeMetadata(xml,row) 			      } 			       			      map = this._getColumnAsMap(row) 			 			      xml.row 			      { 		            map.entrySet().each() 		            { 		               entry -> 		                 key = entry.getKey(); 		                 val = entry.getValue(); 		                 this._addNode(xml,key,val) 		            } 			      } 		     		          cpt++ 		        }  		     } 		     catch (Exception e) 		     { 			   println e.getMessage()  		     } 		   } 		 		  println "Found ${cpt} rows for ${tablename}" 	}	    /*	 create method to add generic node <key>value</value>     *	 little helper to add a Node in the Xml Tree     *      */	private def _addNode(builder,key,value) 	{ 		if ( key != null && value != null)		{			// to do xml.key where key = name or station_id. At the end we will have <station_id> my val </station_id>			builder.invokeMethod(key,value)		}	}         /*    * return SQL Column content (Col name + val) as a Map    */	  	private def _getColumnAsMap(resultSet) 	{ 		def colMap = [:] 		ResultSetMetaData metaData = resultSet.getMetaData(); 		 		int count = metaData.getColumnCount(); 		 		for (int i = 1; i <= count; i++)  		{ 			Object obj = (resultSet.getObject(i) == null) ? "" : resultSet.getObject(i) 			colMap[metaData.getColumnName(i)] = obj     		} 		 		return colMap 	}		/**	 * Execute a request and store its result as xml default	 * @param tablename name of the table to dump	 * @param filename filename where to write the xmlized DB dump	 * @param sampleIDs list of sampleIDs 	 * 	*/	private def _storeRequestResultInXml(tablename,filename,sqlRequest,addMetadata)	{		if (! this._dbConn.isConnected())			throw CTBTOException("Error: Please connect first to the database")				def out    = new File(filename)		def writer = new FileWriter( out )		def xml    = new MarkupBuilder( writer )				def cpt         = 0		def key         = null		def map         = null		def val         = null		def hasMetadata = false				println "Dump ${tablename} content"				xml.table(name:"${tablename}")		{			try			{		      _dbConn.eachRow(sqlRequest) 		      {			      row -> 			      			      if ( (!hasMetadata) && addMetadata) 			      {			    	  hasMetadata = this._storeMetadata(xml,row)			      }			      			      map = this._getColumnAsMap(row)						      xml.row			      {		            map.entrySet().each()		            {		               entry ->		                 key = entry.getKey();		                 val = entry.getValue();		                 this._addNode(xml,key,val)		            }			      }		    		          cpt++		        } 		     }		     catch (Exception e)		     {			   println e.getMessage() 		     }		   }				  if (cpt > 0)		  {		     println "Found ${cpt} rows for ${tablename}."		  }		  else		  {			  // delete file as there is no data			  if (out.exists())			  {				println("No data retrieved for ${tablename}.")				//println "Delete ${filename} as there is no data related to the specified sampleIDs in ${tablename}"			    out.delete();			  }		  }	}
}